# ===================================================================
# DOCKERFILE DOCUMENTADO PARA ESTUDIO - DevOps TP
# ===================================================================
# Este archivo documenta el Dockerfile REAL que funciona en el proyecto
# Implementa un build multi-stage para optimizar la imagen final
# ===================================================================

# -------- ETAPA 1: INSTALACI√ìN DE DEPENDENCIAS --------
FROM node:20-alpine AS deps
# - Usamos Node.js 20 con Alpine Linux (imagen ligera: ~110MB vs ~900MB)
# - Alpine es una distribuci√≥n Linux minimalista ideal para containers

WORKDIR /app
# Establecemos /app como directorio de trabajo dentro del container

COPY package*.json yarn.lock* ./
# Copiamos SOLO los archivos de dependencias primero
# Estrategia para aprovechar Docker layer caching:
# - Si package.json no cambia, esta capa se reutiliza
# - yarn install solo se ejecuta cuando cambian las dependencias

RUN yarn install --frozen-lockfile
# --frozen-lockfile: Usa versiones exactas del yarn.lock
# Garantiza builds reproducibles y consistentes entre entornos

# -------- ETAPA 2: BUILD DE LA APLICACI√ìN --------
FROM node:20-alpine AS builder
# Nueva imagen para el proceso de build (separaci√≥n de responsabilidades)

WORKDIR /app

COPY --from=deps /app/node_modules ./node_modules
# Copiamos node_modules de la etapa anterior (optimizaci√≥n)
# Evita reinstalar dependencias innecesariamente

COPY . .
# Copiamos TODO el c√≥digo fuente (src/, tsconfig.json, etc.)

RUN yarn build
# Ejecuta el script "build" definido en package.json
# Compila TypeScript a JavaScript usando tsc
# Genera la carpeta /dist con c√≥digo JavaScript listo para producci√≥n

# -------- ETAPA 3: IMAGEN DE PRODUCCI√ìN --------
FROM node:20-alpine AS runner
# Imagen final LIMPIA solo con lo necesario para ejecutar

WORKDIR /app

# Copiamos SOLO lo necesario de la etapa builder:
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/node_modules ./node_modules  
COPY --from=builder /app/dist ./dist

# NOTA IMPORTANTE: La l√≠nea "COPY .env .env" fue REMOVIDA por seguridad
# En CI/CD y producci√≥n, las variables de entorno se pasan como ENV vars
# del container, no copiando archivos .env

EXPOSE 8081
# Exponemos puerto 8081 donde corre Express.js

CMD ["node", "dist/server.js"]
# Comando por defecto: ejecutar el archivo JavaScript compilado
# server.js est√° en /dist porque TypeScript lo compil√≥ ah√≠

# ===================================================================
# üöÄ RESULTADO FINAL:
# ===================================================================
# ‚úÖ Imagen optimizada (~150MB vs ~800MB sin multi-stage)
# ‚úÖ Solo contiene runtime necesario (no c√≥digo fuente, no devDependencies)
# ‚úÖ Mayor seguridad (no expone c√≥digo TypeScript original)
# ‚úÖ Builds m√°s r√°pidos gracias al layer caching
# ‚úÖ Lista para CI/CD y producci√≥n
# ===================================================================